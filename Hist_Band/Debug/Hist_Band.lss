
Hist_Band.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00803f00  00803f00  000002e2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000023c  00000100  00000100  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000012  0000833c  0000033c  000002d0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000001a  00803f00  00803f00  000002e2  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  000002e2  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000314  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000000e0  00000000  00000000  00000350  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002fba  00000000  00000000  00000430  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001d5f  00000000  00000000  000033ea  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000008d9  00000000  00000000  00005149  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001bc  00000000  00000000  00005a24  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001648  00000000  00000000  00005be0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000002ac  00000000  00000000  00007228  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000090  00000000  00000000  000074d4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000100 <__vectors>:
 100:	19 c0       	rjmp	.+50     	; 0x134 <__ctors_end>
 102:	33 c0       	rjmp	.+102    	; 0x16a <__bad_interrupt>
 104:	32 c0       	rjmp	.+100    	; 0x16a <__bad_interrupt>
 106:	31 c0       	rjmp	.+98     	; 0x16a <__bad_interrupt>
 108:	30 c0       	rjmp	.+96     	; 0x16a <__bad_interrupt>
 10a:	2f c0       	rjmp	.+94     	; 0x16a <__bad_interrupt>
 10c:	e3 c0       	rjmp	.+454    	; 0x2d4 <__vector_6>
 10e:	2d c0       	rjmp	.+90     	; 0x16a <__bad_interrupt>
 110:	2c c0       	rjmp	.+88     	; 0x16a <__bad_interrupt>
 112:	2b c0       	rjmp	.+86     	; 0x16a <__bad_interrupt>
 114:	2a c0       	rjmp	.+84     	; 0x16a <__bad_interrupt>
 116:	29 c0       	rjmp	.+82     	; 0x16a <__bad_interrupt>
 118:	28 c0       	rjmp	.+80     	; 0x16a <__bad_interrupt>
 11a:	27 c0       	rjmp	.+78     	; 0x16a <__bad_interrupt>
 11c:	26 c0       	rjmp	.+76     	; 0x16a <__bad_interrupt>
 11e:	25 c0       	rjmp	.+74     	; 0x16a <__bad_interrupt>
 120:	24 c0       	rjmp	.+72     	; 0x16a <__bad_interrupt>
 122:	24 c0       	rjmp	.+72     	; 0x16c <__vector_17>
 124:	22 c0       	rjmp	.+68     	; 0x16a <__bad_interrupt>
 126:	21 c0       	rjmp	.+66     	; 0x16a <__bad_interrupt>
 128:	20 c0       	rjmp	.+64     	; 0x16a <__bad_interrupt>
 12a:	1f c0       	rjmp	.+62     	; 0x16a <__bad_interrupt>
 12c:	a8 c0       	rjmp	.+336    	; 0x27e <__vector_22>
 12e:	1d c0       	rjmp	.+58     	; 0x16a <__bad_interrupt>
 130:	1c c0       	rjmp	.+56     	; 0x16a <__bad_interrupt>
 132:	1b c0       	rjmp	.+54     	; 0x16a <__bad_interrupt>

00000134 <__ctors_end>:
 134:	11 24       	eor	r1, r1
 136:	1f be       	out	0x3f, r1	; 63
 138:	cf ef       	ldi	r28, 0xFF	; 255
 13a:	cd bf       	out	0x3d, r28	; 61
 13c:	df e3       	ldi	r29, 0x3F	; 63
 13e:	de bf       	out	0x3e, r29	; 62

00000140 <__do_copy_data>:
 140:	1f e3       	ldi	r17, 0x3F	; 63
 142:	a0 e0       	ldi	r26, 0x00	; 0
 144:	bf e3       	ldi	r27, 0x3F	; 63
 146:	ee e4       	ldi	r30, 0x4E	; 78
 148:	f3 e0       	ldi	r31, 0x03	; 3
 14a:	02 c0       	rjmp	.+4      	; 0x150 <__do_copy_data+0x10>
 14c:	05 90       	lpm	r0, Z+
 14e:	0d 92       	st	X+, r0
 150:	a0 30       	cpi	r26, 0x00	; 0
 152:	b1 07       	cpc	r27, r17
 154:	d9 f7       	brne	.-10     	; 0x14c <__do_copy_data+0xc>

00000156 <__do_clear_bss>:
 156:	2f e3       	ldi	r18, 0x3F	; 63
 158:	a0 e0       	ldi	r26, 0x00	; 0
 15a:	bf e3       	ldi	r27, 0x3F	; 63
 15c:	01 c0       	rjmp	.+2      	; 0x160 <.do_clear_bss_start>

0000015e <.do_clear_bss_loop>:
 15e:	1d 92       	st	X+, r1

00000160 <.do_clear_bss_start>:
 160:	aa 31       	cpi	r26, 0x1A	; 26
 162:	b2 07       	cpc	r27, r18
 164:	e1 f7       	brne	.-8      	; 0x15e <.do_clear_bss_loop>
 166:	c7 d0       	rcall	.+398    	; 0x2f6 <main>
 168:	e7 c0       	rjmp	.+462    	; 0x338 <_exit>

0000016a <__bad_interrupt>:
 16a:	ca cf       	rjmp	.-108    	; 0x100 <__vectors>

0000016c <__vector_17>:
Clears the Interrupt Flag: The interruption can't be triggered repeatedly until a new condition occurs
Reads the ADC Result: The ADC0 conversion data is stored in the global variable "sample"
Starts a New Conversion: The ISR triggers a new ADC conversion, ensuring that the ADC is 
continuously sampling new data and the process is ongoing.*/
ISR(ADC0_RESRDY_vect)
{
 16c:	1f 92       	push	r1
 16e:	0f 92       	push	r0
 170:	0f b6       	in	r0, 0x3f	; 63
 172:	0f 92       	push	r0
 174:	11 24       	eor	r1, r1
 176:	2f 93       	push	r18
 178:	3f 93       	push	r19
 17a:	8f 93       	push	r24
 17c:	ef 93       	push	r30
 17e:	ff 93       	push	r31
	/* Clear the interrupt flag by writing 1: */
	ADC0.INTFLAGS = ADC_RESRDY_bm;
 180:	e0 e0       	ldi	r30, 0x00	; 0
 182:	f6 e0       	ldi	r31, 0x06	; 6
 184:	81 e0       	ldi	r24, 0x01	; 1
 186:	83 87       	std	Z+11, r24	; 0x0b
	
	sample = ADC0.RES;
 188:	20 89       	ldd	r18, Z+16	; 0x10
 18a:	31 89       	ldd	r19, Z+17	; 0x11
 18c:	20 93 18 3f 	sts	0x3F18, r18	; 0x803f18 <sample>
 190:	30 93 19 3f 	sts	0x3F19, r19	; 0x803f19 <sample+0x1>
	
	/* Start conversion */
	ADC0.COMMAND = ADC_STCONV_bm;
 194:	80 87       	std	Z+8, r24	; 0x08
}
 196:	ff 91       	pop	r31
 198:	ef 91       	pop	r30
 19a:	8f 91       	pop	r24
 19c:	3f 91       	pop	r19
 19e:	2f 91       	pop	r18
 1a0:	0f 90       	pop	r0
 1a2:	0f be       	out	0x3f, r0	; 63
 1a4:	0f 90       	pop	r0
 1a6:	1f 90       	pop	r1
 1a8:	18 95       	reti

000001aa <ADC0_init>:
/*This initialization ensures that the ADC is ready to perform accurate 
conversions and trigger interrupts when new conversion results are available.*/
void ADC0_init(void)
{
	/* Disable digital input buffer */
	PORTA.PIN4CTRL &= ~PORT_ISC_gm;
 1aa:	e0 e0       	ldi	r30, 0x00	; 0
 1ac:	f4 e0       	ldi	r31, 0x04	; 4
 1ae:	84 89       	ldd	r24, Z+20	; 0x14
 1b0:	88 7f       	andi	r24, 0xF8	; 248
 1b2:	84 8b       	std	Z+20, r24	; 0x14
	PORTA.PIN4CTRL |= PORT_ISC_INPUT_DISABLE_gc;
 1b4:	84 89       	ldd	r24, Z+20	; 0x14
 1b6:	84 60       	ori	r24, 0x04	; 4
 1b8:	84 8b       	std	Z+20, r24	; 0x14
	
	/* Disable pull-up resistor */
	PORTA.PIN4CTRL &= ~PORT_PULLUPEN_bm;
 1ba:	84 89       	ldd	r24, Z+20	; 0x14
 1bc:	87 7f       	andi	r24, 0xF7	; 247
 1be:	84 8b       	std	Z+20, r24	; 0x14
	
	VREF.CTRLA |= VREF_ADC0REFSEL_2V5_gc;	/* Voltage reference  2.5V */
 1c0:	e0 ea       	ldi	r30, 0xA0	; 160
 1c2:	f0 e0       	ldi	r31, 0x00	; 0
 1c4:	80 81       	ld	r24, Z
 1c6:	80 62       	ori	r24, 0x20	; 32
 1c8:	80 83       	st	Z, r24
	VREF.CTRLB |= VREF_ADC0REFEN_bm;		/* Force Voltage reference */
 1ca:	81 81       	ldd	r24, Z+1	; 0x01
 1cc:	82 60       	ori	r24, 0x02	; 2
 1ce:	81 83       	std	Z+1, r24	; 0x01
	
	ADC0.CTRLC = ADC_PRESC_DIV8_gc |		/* CLK_PER divided by 8 */
 1d0:	e0 e0       	ldi	r30, 0x00	; 0
 1d2:	f6 e0       	ldi	r31, 0x06	; 6
 1d4:	82 e0       	ldi	r24, 0x02	; 2
 1d6:	82 83       	std	Z+2, r24	; 0x02
	ADC_REFSEL_INTREF_gc;					/* Internal reference */
	
	ADC0.CTRLA |= ADC_ENABLE_bm |			/* ADC Enable: enabled */
 1d8:	80 81       	ld	r24, Z
 1da:	81 60       	ori	r24, 0x01	; 1
 1dc:	80 83       	st	Z, r24
	ADC_RESSEL_10BIT_gc;					/* 10-bit mode */
	
	/* Enable ADC interrupt */
	ADC0.INTCTRL = ADC_RESRDY_bm;
 1de:	81 e0       	ldi	r24, 0x01	; 1
 1e0:	82 87       	std	Z+10, r24	; 0x0a
	
	/* Select ADC channel */
	ADC0.MUXPOS = ADC_MUXPOS_AIN4_gc;
 1e2:	84 e0       	ldi	r24, 0x04	; 4
 1e4:	86 83       	std	Z+6, r24	; 0x06
 1e6:	08 95       	ret

000001e8 <ADC0_start>:
After starting the conversion, the ADC will sample the input signal, convert it to a digital value, and set an interrupt flag 
(if configured) when the conversion is complete, allowing the program to read the result.*/
void ADC0_start(void)
{
	/* Start conversion */
	ADC0.COMMAND = ADC_STCONV_bm;
 1e8:	81 e0       	ldi	r24, 0x01	; 1
 1ea:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <__RODATA_PM_OFFSET__+0x7f8608>
 1ee:	08 95       	ret

000001f0 <CLKCTRL_init>:
It sets the clock prescaler to divide the system clock by 8 and enables the prescaler.
It configures the 20 MHz internal oscillator as the clock source and disables clock output to external pins.
It waits until the clock system has stabilized and the changes are applied. */
void CLKCTRL_init(void)
{
	_PROTECTED_WRITE(CLKCTRL.MCLKCTRLB, CLKCTRL_PDIV_16X_gc | CLKCTRL_PEN_bm);
 1f0:	88 ed       	ldi	r24, 0xD8	; 216
 1f2:	27 e0       	ldi	r18, 0x07	; 7
 1f4:	30 e0       	ldi	r19, 0x00	; 0
 1f6:	84 bf       	out	0x34, r24	; 52
 1f8:	20 93 61 00 	sts	0x0061, r18	; 0x800061 <__RODATA_PM_OFFSET__+0x7f8061>
	_PROTECTED_WRITE(CLKCTRL.MCLKCTRLA, !CLKCTRL_CLKOUT_bm | CLKCTRL_CLKSEL_OSC20M_gc);
 1fc:	20 e0       	ldi	r18, 0x00	; 0
 1fe:	30 e0       	ldi	r19, 0x00	; 0
 200:	84 bf       	out	0x34, r24	; 52
 202:	20 93 60 00 	sts	0x0060, r18	; 0x800060 <__RODATA_PM_OFFSET__+0x7f8060>
	while (!(CLKCTRL.MCLKSTATUS));
 206:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <__RODATA_PM_OFFSET__+0x7f8063>
 20a:	88 23       	and	r24, r24
 20c:	e1 f3       	breq	.-8      	; 0x206 <CLKCTRL_init+0x16>
}
 20e:	08 95       	ret

00000210 <RTC_init>:
It sets the period value to 0x44 (68 decimal), meaning the RTC will generate an overflow event after counting to this value.
It enables the overflow interrupt, so that an interrupt is triggered when the RTC overflows,
while disabling the compare match interrupt. */
void RTC_init(void)
{
	RTC.CTRLA = RTC_PRESCALER_DIV512_gc /* 512 */
 210:	e0 e4       	ldi	r30, 0x40	; 64
 212:	f1 e0       	ldi	r31, 0x01	; 1
 214:	89 e4       	ldi	r24, 0x49	; 73
 216:	80 83       	st	Z, r24
	| 1 << RTC_RTCEN_bp     /* Enable: enabled */
	| 0 << RTC_RUNSTDBY_bp; /* Run In Standby: disabled */

	RTC.PER = 0x44; /* Period: 0xd */
 218:	84 e4       	ldi	r24, 0x44	; 68
 21a:	90 e0       	ldi	r25, 0x00	; 0
 21c:	82 87       	std	Z+10, r24	; 0x0a
 21e:	93 87       	std	Z+11, r25	; 0x0b

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
 220:	81 e0       	ldi	r24, 0x01	; 1
 222:	82 83       	std	Z+2, r24	; 0x02
 224:	08 95       	ret

00000226 <GPIO_init>:
#include "gpio.h"

/*This function looks for the direction of PORTA and configures its pin 2 as an output pin*/
void GPIO_init(void)
{
	PORTA.DIR |= PIN2_bm;
 226:	e0 e0       	ldi	r30, 0x00	; 0
 228:	f4 e0       	ldi	r31, 0x04	; 4
 22a:	80 81       	ld	r24, Z
 22c:	84 60       	ori	r24, 0x04	; 4
 22e:	80 83       	st	Z, r24
 230:	08 95       	ret

00000232 <UART_init>:
/*This function initializes the UART with the necessary parameters like baud rate, and activating both
Receiver and Transmitter so it can get and send data though the same UART*/
void UART_init()
{

	USART0.BAUD = (uint16_t)USART0_BAUD_RATE(9600); /* set baud rate register */
 232:	e0 e0       	ldi	r30, 0x00	; 0
 234:	f8 e0       	ldi	r31, 0x08	; 8
 236:	81 ea       	ldi	r24, 0xA1	; 161
 238:	91 e0       	ldi	r25, 0x01	; 1
 23a:	80 87       	std	Z+8, r24	; 0x08
 23c:	91 87       	std	Z+9, r25	; 0x09

	USART0.CTRLA = USART_RXCIE_bm;  /* Receive Complete Interrupt Enable: enabled */
 23e:	80 e8       	ldi	r24, 0x80	; 128
 240:	85 83       	std	Z+5, r24	; 0x05
	
	USART0.CTRLB = USART_RXEN_bm |    /* Receiver Enable: enabled */
 242:	80 ec       	ldi	r24, 0xC0	; 192
 244:	86 83       	std	Z+6, r24	; 0x06
	USART_TXEN_bm;    /* Transmitter Enable: enabled */
	
	/* Set TxD (PB2) as output */
	PORTB.DIR |= PIN2_bm;
 246:	e0 e2       	ldi	r30, 0x20	; 32
 248:	f4 e0       	ldi	r31, 0x04	; 4
 24a:	80 81       	ld	r24, Z
 24c:	84 60       	ori	r24, 0x04	; 4
 24e:	80 83       	st	Z, r24
 250:	08 95       	ret

00000252 <UART_SendString>:

/*This function takes a string and sends each character over UART until it reaches the end of the string (null terminator).
It ensures that each byte is sent only when the transmit buffer is empty and 
waits for the entire transmission to complete before clearing the corresponding flag.*/
void UART_SendString(const char *str)
{
 252:	fc 01       	movw	r30, r24
	while (*str != '\0')
 254:	07 c0       	rjmp	.+14     	; 0x264 <UART_SendString+0x12>
	{
		while (!(USART0.STATUS & USART_DREIF_bm)); //wait until Tx buffer is empty
 256:	90 91 04 08 	lds	r25, 0x0804	; 0x800804 <__RODATA_PM_OFFSET__+0x7f8804>
 25a:	95 ff       	sbrs	r25, 5
 25c:	fc cf       	rjmp	.-8      	; 0x256 <UART_SendString+0x4>
		
		USART0.TXDATAL = *str;
 25e:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__RODATA_PM_OFFSET__+0x7f8802>
		str++;
 262:	31 96       	adiw	r30, 0x01	; 1
/*This function takes a string and sends each character over UART until it reaches the end of the string (null terminator).
It ensures that each byte is sent only when the transmit buffer is empty and 
waits for the entire transmission to complete before clearing the corresponding flag.*/
void UART_SendString(const char *str)
{
	while (*str != '\0')
 264:	80 81       	ld	r24, Z
 266:	81 11       	cpse	r24, r1
 268:	f6 cf       	rjmp	.-20     	; 0x256 <UART_SendString+0x4>
		while (!(USART0.STATUS & USART_DREIF_bm)); //wait until Tx buffer is empty
		
		USART0.TXDATAL = *str;
		str++;
	}
	while (!(USART0.STATUS & USART_TXCIF_bm)); //wait until Tx finished
 26a:	80 91 04 08 	lds	r24, 0x0804	; 0x800804 <__RODATA_PM_OFFSET__+0x7f8804>
 26e:	86 ff       	sbrs	r24, 6
 270:	fc cf       	rjmp	.-8      	; 0x26a <UART_SendString+0x18>
	
	USART0.STATUS |= USART_TXCIF_bm;
 272:	e0 e0       	ldi	r30, 0x00	; 0
 274:	f8 e0       	ldi	r31, 0x08	; 8
 276:	84 81       	ldd	r24, Z+4	; 0x04
 278:	80 64       	ori	r24, 0x40	; 64
 27a:	84 83       	std	Z+4, r24	; 0x04
 27c:	08 95       	ret

0000027e <__vector_22>:
It stores the received byte in RXBuffer at the current rx_index.
The code checks if the byte is a newline (0x0A) or if the buffer is full. If either is true, the rx_index is reset to 0 
to prepare for the next message. Otherwise, the rx_index is incremented to store the next byte in the buffer.
The commented DataRDY = true; line is used to indicate when a complete message has been received.*/
ISR(USART0_RXC_vect)
{
 27e:	1f 92       	push	r1
 280:	0f 92       	push	r0
 282:	0f b6       	in	r0, 0x3f	; 63
 284:	0f 92       	push	r0
 286:	11 24       	eor	r1, r1
 288:	8f 93       	push	r24
 28a:	9f 93       	push	r25
 28c:	ef 93       	push	r30
 28e:	ff 93       	push	r31
	RXBuffer[rx_index] = USART0.RXDATAL;
 290:	80 91 00 3f 	lds	r24, 0x3F00	; 0x803f00 <__DATA_REGION_ORIGIN__>
 294:	e8 2f       	mov	r30, r24
 296:	f0 e0       	ldi	r31, 0x00	; 0
 298:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <__RODATA_PM_OFFSET__+0x7f8800>
 29c:	ec 5f       	subi	r30, 0xFC	; 252
 29e:	f0 4c       	sbci	r31, 0xC0	; 192
 2a0:	90 83       	st	Z, r25
	
	if((RXBuffer[rx_index] == 0x0A) || (rx_index == 20)) {
 2a2:	9a 30       	cpi	r25, 0x0A	; 10
 2a4:	11 f0       	breq	.+4      	; 0x2aa <__vector_22+0x2c>
 2a6:	84 31       	cpi	r24, 0x14	; 20
 2a8:	49 f4       	brne	.+18     	; 0x2bc <__vector_22+0x3e>
		UART_drdy = true;
 2aa:	81 e0       	ldi	r24, 0x01	; 1
 2ac:	90 e0       	ldi	r25, 0x00	; 0
 2ae:	80 93 01 3f 	sts	0x3F01, r24	; 0x803f01 <UART_drdy>
 2b2:	90 93 02 3f 	sts	0x3F02, r25	; 0x803f02 <sensor_drdy>
		rx_index = 0;
 2b6:	10 92 00 3f 	sts	0x3F00, r1	; 0x803f00 <__DATA_REGION_ORIGIN__>
 2ba:	03 c0       	rjmp	.+6      	; 0x2c2 <__vector_22+0x44>
		} else {
		rx_index++;
 2bc:	8f 5f       	subi	r24, 0xFF	; 255
 2be:	80 93 00 3f 	sts	0x3F00, r24	; 0x803f00 <__DATA_REGION_ORIGIN__>
	}
}
 2c2:	ff 91       	pop	r31
 2c4:	ef 91       	pop	r30
 2c6:	9f 91       	pop	r25
 2c8:	8f 91       	pop	r24
 2ca:	0f 90       	pop	r0
 2cc:	0f be       	out	0x3f, r0	; 63
 2ce:	0f 90       	pop	r0
 2d0:	1f 90       	pop	r1
 2d2:	18 95       	reti

000002d4 <__vector_6>:

int low_threshold = 0xFF;
int upper_threshold = 0xFF;

ISR(RTC_CNT_vect)
{
 2d4:	1f 92       	push	r1
 2d6:	0f 92       	push	r0
 2d8:	0f b6       	in	r0, 0x3f	; 63
 2da:	0f 92       	push	r0
 2dc:	11 24       	eor	r1, r1
 2de:	8f 93       	push	r24
	/* Insert your RTC Overflow interrupt handling code */
	sensor_drdy = true;
 2e0:	81 e0       	ldi	r24, 0x01	; 1
 2e2:	80 93 02 3f 	sts	0x3F02, r24	; 0x803f02 <sensor_drdy>
	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
 2e6:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <__RODATA_PM_OFFSET__+0x7f8143>
}
 2ea:	8f 91       	pop	r24
 2ec:	0f 90       	pop	r0
 2ee:	0f be       	out	0x3f, r0	; 63
 2f0:	0f 90       	pop	r0
 2f2:	1f 90       	pop	r1
 2f4:	18 95       	reti

000002f6 <main>:

int main(void)
{
 2f6:	cf 93       	push	r28
 2f8:	df 93       	push	r29
 2fa:	cd b7       	in	r28, 0x3d	; 61
 2fc:	de b7       	in	r29, 0x3e	; 62
 2fe:	a8 97       	sbiw	r28, 0x28	; 40
 300:	cd bf       	out	0x3d, r28	; 61
 302:	de bf       	out	0x3e, r29	; 62
	/* Configure modules, Initialize all needed functions */
	CLKCTRL_init();
 304:	75 df       	rcall	.-278    	; 0x1f0 <CLKCTRL_init>
	RTC_init();
 306:	84 df       	rcall	.-248    	; 0x210 <RTC_init>
	ADC0_init();
 308:	50 df       	rcall	.-352    	; 0x1aa <ADC0_init>
	GPIO_init();
 30a:	8d df       	rcall	.-230    	; 0x226 <GPIO_init>
	UART_init();
 30c:	92 df       	rcall	.-220    	; 0x232 <UART_init>
	
	countTime = 0;	//Seconds counter
 30e:	10 92 03 3f 	sts	0x3F03, r1	; 0x803f03 <countTime>
	char CommCon[40];	//String buffer
	
	memset(CommCon,0,40);	//Cleans the buffer by adding zeros to each position
 312:	ce 01       	movw	r24, r28
 314:	01 96       	adiw	r24, 0x01	; 1
 316:	28 e2       	ldi	r18, 0x28	; 40
 318:	fc 01       	movw	r30, r24
 31a:	11 92       	st	Z+, r1
 31c:	2a 95       	dec	r18
 31e:	e9 f7       	brne	.-6      	; 0x31a <main+0x24>
	sprintf(CommCon, "HisBand Pro 1.0\r\n");
 320:	22 e1       	ldi	r18, 0x12	; 18
 322:	ec e3       	ldi	r30, 0x3C	; 60
 324:	f3 e8       	ldi	r31, 0x83	; 131
 326:	dc 01       	movw	r26, r24
 328:	01 90       	ld	r0, Z+
 32a:	0d 92       	st	X+, r0
 32c:	2a 95       	dec	r18
 32e:	e1 f7       	brne	.-8      	; 0x328 <main+0x32>
	UART_SendString(CommCon);
 330:	90 df       	rcall	.-224    	; 0x252 <UART_SendString>
	
	/* Enable global interrupt */
	sei();
 332:	78 94       	sei
	
	/* Start a conversion */
	ADC0_start();
 334:	59 df       	rcall	.-334    	; 0x1e8 <ADC0_start>
 336:	ff cf       	rjmp	.-2      	; 0x336 <main+0x40>

00000338 <_exit>:
 338:	f8 94       	cli

0000033a <__stop_program>:
 33a:	ff cf       	rjmp	.-2      	; 0x33a <__stop_program>
